/*
 * generated by Xtext 2.23.0
 */
package org.palladiosimulator.dataflow.dictionary.characterized.dsl.scoping;

import java.util.ArrayList;
import java.util.Optional;

import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EReference;
import org.eclipse.xtext.naming.QualifiedName;
import org.eclipse.xtext.resource.IEObjectDescription;
import org.eclipse.xtext.resource.impl.AliasedEObjectDescription;
import org.eclipse.xtext.scoping.IScope;
import org.eclipse.xtext.scoping.impl.FilteringScope;
import org.palladiosimulator.dataflow.dictionary.characterized.DataDictionaryCharacterized.BehaviorDefinition;
import org.palladiosimulator.dataflow.dictionary.characterized.DataDictionaryCharacterized.expressions.ExpressionsPackage;

/**
 * This class contains custom scoping description.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#scoping
 * on how and when to use it.
 */
public class CharacterizedDataDictionaryScopeProvider extends AbstractCharacterizedDataDictionaryScopeProvider {

    @Override
    public IScope getScope(EObject context, EReference reference) {
        var superScope = super.getScope(context, reference);
        if (reference == ExpressionsPackage.Literals.DATA_CHARACTERISTIC_REFERENCE__PIN) {
            var behaviorDefinition = findParentOfType(context, BehaviorDefinition.class);
            var usablePins = new ArrayList<>();
            behaviorDefinition.map(BehaviorDefinition::getInputs)
                .ifPresent(usablePins::addAll);
            behaviorDefinition.map(BehaviorDefinition::getOutputs)
                .ifPresent(usablePins::addAll);
            return new FilteringScope(superScope, description -> usablePins.contains(description.getEObjectOrProxy()));
        }
        if (reference == ExpressionsPackage.Literals.ENUM_CHARACTERISTIC_REFERENCE__LITERAL) {
            return new TransformingScope(superScope, description -> Optional.ofNullable(description)
                .map(d -> (IEObjectDescription) new AliasedEObjectDescription(
                        QualifiedName.create(description.getQualifiedName()
                            .getLastSegment()),
                        d))
                .orElse(description));
        }
        return superScope;
    }

    @SuppressWarnings("unchecked")
    protected <T extends EObject> Optional<T> findParentOfType(EObject object, Class<T> parentType) {
        EObject currentObject = object;
        while (currentObject != null) {
            if (parentType.isInstance(currentObject)) {
                return Optional.of((T)currentObject);
            }
            currentObject = currentObject.eContainer();
        }
        return Optional.empty();
    }

}
